// Generated by CoffeeScript 1.3.3
(function() {
  var Material, async, error, fs, inspect, len, log, readPath, rgbToHex, rgbToInt, setPixel, toRGB, wait, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  fs = require('fs');

  _ref1 = require('./toolbox'), wait = _ref1.wait, async = _ref1.async;

  len = function(p1, p2) {
    var dx, dy, dz, sm;
    dx = p2[0] - p1[0];
    dy = p2[1] - p1[1];
    dz = p2[2] - p1[2];
    sm = dx * dx + dy * dy + dz * dz;
    return Math.round(Math.sqrt(sm));
  };

  readPath = function(p1, p2) {
    var dx, dy, dz, i, points, r, resolution, sm, x, y, z, _i;
    dx = p2[0] - p1[0];
    dy = p2[1] - p1[1];
    dz = p2[2] - p1[2];
    sm = dx * dx + dy * dy + dz * dz;
    resolution = Math.round(Math.sqrt(sm));
    if (resolution < 1) {
      return [];
    }
    points = [];
    for (i = _i = 0; 0 <= resolution ? _i <= resolution : _i >= resolution; i = 0 <= resolution ? ++_i : --_i) {
      r = i / resolution;
      x = Math.round(p1[0] + dx * r);
      y = Math.round(p1[1] + dy * r);
      z = Math.round(p1[2] + dz * r);
      points.push([x, y, z]);
    }
    return points;
  };

  toRGB = function(num) {
    return [num >> 16, num >> 8 & 255, num & 255];
  };

  rgbToInt = function(r, g, b) {
    return (r << 16) + (g << 8) + b;
  };

  rgbToHex = function(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  };

  setPixel = function(img, x, y, r, g, b, a) {
    var index;
    index = (x + y * img.width) * 4;
    img.data[index + 0] = r;
    img.data[index + 1] = g;
    img.data[index + 2] = b;
    return img.data[index + 3] = a;
  };

  Material = (function() {

    function Material(id, name, color, type) {
      var b, g, r, _ref2;
      this.id = id;
      this.name = name;
      this.color = color;
      this.type = type != null ? type : 'continuous';
      _ref2 = this.rgb = toRGB(this.id), r = _ref2[0], g = _ref2[1], b = _ref2[2];
      this.rgbaString = "rgba(" + r + "," + g + "," + b + ",0)";
      this.hexString = rgbToHex(r, g, b);
      this.rgbInt = rgbToInt(r, g, b);
    }

    Material.prototype.toString = function() {
      return "mat " + this.id + " (" + this.name + ") is " + this.color + " and " + this.type;
    };

    return Material;

  })();

  module.exports = (function() {

    function exports(options) {
      this.savePng = __bind(this.savePng, this);

      this.save = __bind(this.save, this);

      this.dig = __bind(this.dig, this);

      this.trace = __bind(this.trace, this);

      this.readVoxel = __bind(this.readVoxel, this);

      this.sphere = __bind(this.sphere, this);

      this.dot = __bind(this.dot, this);
      this.size = {
        x: 32,
        y: 32,
        z: 32
      };
      if (options.size != null) {
        if (options.size.length === 3) {
          this.size.x = Math.round(Number(options.size[0]));
          this.size.y = Math.round(Number(options.size[1]));
          this.size.z = Math.round(Number(options.size[2]));
        }
      }
      this.width = Math.abs(this.size.x);
      this.height = Math.abs(this.size.y);
      this.depth = Math.abs(this.size.z);
      this.points = {};
      this.count = 0;
      this.materials = {};
      this.currentMaterial = false;
      this.createMaterial("vacuum", "invisible", "vacuum");
    }

    exports.prototype.createMaterial = function(name, color, type) {
      var id, material;
      id = Object.keys(this.materials).length;
      material = new Material(id, name, color, type);
      this.materials[id] = material;
      return material;
    };

    exports.prototype.use = function(material) {
      var msg;
      if (material) {
        return this.currentMaterial = material;
      } else {
        msg = "Error, no material";
        error(msg);
        throw msg;
      }
    };

    exports.prototype.dot = function(p) {
      var id;
      id = "" + (Math.round(p[0])) + "," + (Math.round(p[1])) + "," + (Math.round(p[2]));
      if (!(id in this.points)) {
        this.count++;
      }
      return this.points[id] = this.currentMaterial;
    };

    exports.prototype.line = function(p1, p2, material) {
      var p, points, _i, _len, _results;
      if (material == null) {
        material = false;
      }
      points = readPath(p1, p2);
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        _results.push(this.dot(p));
      }
      return _results;
    };

    exports.prototype.sphere = function(p, radius) {
      var M, N, f, m, n, res, s, x, y, z, _i, _results;
      res = radius;
      M = res * 3;
      N = res * 6;
      f = function(m, n) {
        return [Math.sin(Math.PI * m / M) * Math.cos(Math.PI * 2 * n / N), Math.sin(Math.PI * m / M) * Math.sin(Math.PI * 2 * n / N), Math.cos(Math.PI * m / M)];
      };
      _results = [];
      for (m = _i = 0; 0 <= M ? _i <= M : _i >= M; m = 0 <= M ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (n = _j = 0; 0 <= N ? _j < N : _j > N; n = 0 <= N ? ++_j : --_j) {
            s = f(m, n);
            _ref2 = [Math.round(p[0] + s[0] * radius), Math.round(p[1] + s[1] * radius), Math.round(p[2] + s[2] * radius)], x = _ref2[0], y = _ref2[1], z = _ref2[2];
            _results1.push(this.dot([x, y, z]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    exports.prototype.readVoxel = function(p) {
      var id, m;
      id = "" + (Math.round(p[0])) + "," + (Math.round(p[1])) + "," + (Math.round(p[2]));
      m = this.points[id];
      if (m != null) {
        return m;
      } else {
        return this.materials[0];
      }
    };

    exports.prototype.trace = function(keypoints, fn) {
      var i, point, points, _i, _ref2, _results;
      _results = [];
      for (i = _i = 0, _ref2 = keypoints.length - 1; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        points = readPath(keypoints[i], keypoints[i + 1]);
        _results.push((function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = points.length; _j < _len; _j++) {
            point = points[_j];
            _results1.push(fn(point));
          }
          return _results1;
        })());
      }
      return _results;
    };

    exports.prototype.dig = function() {};

    exports.prototype.save = function(path, onComplete) {
      var _this = this;
      if (onComplete == null) {
        onComplete = function() {};
      }
      return async(function() {
        var Exporter, exp, ext, id, material, milestone, msg, progress, s, wrote, x, y, z, _ref2, _ref3;
        ext = path.split(".").slice(-1);
        Exporter = require("./exporters/" + ext);
        if (!Exporter) {
          msg = "could not find exporter for format " + ext;
          error(msg);
          throw msg;
          onComplete();
          return;
        }
        exp = new Exporter(path, {
          nbPoints: _this.count,
          width: _this.width,
          height: _this.height,
          depth: _this.depth,
          matrix: function(p) {
            return _this.readVoxel(p);
          },
          onEnd: function() {
            return onComplete();
          }
        });
        wrote = 0;
        progress = 0;
        milestone = Math.round(_this.count * 0.1);
        log("writing voxels:");
        _ref2 = _this.points;
        for (id in _ref2) {
          material = _ref2[id];
          s = id.split(',');
          _ref3 = [parseInt(s[0]), parseInt(s[1]), parseInt(s[2])], x = _ref3[0], y = _ref3[1], z = _ref3[2];
          exp.write(x, y, z, material);
          wrote++;
          if (!(wrote % milestone)) {
            progress += 10;
            log(" " + progress + "% (" + wrote + ")");
          }
        }
        log(" generated 100% (" + wrote + "}) of geometries, writing to disk..");
        return exp.close();
      });
    };

    exports.prototype.savePng = function(path) {
      var i, out, p, slice, stream, _i, _len, _ref2, _results;
      if (path == null) {
        path = false;
      }
      log("saving:");
      i = -1;
      if (!path) {
        path = __dirname + "/";
      }
      _ref2 = this.slices;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        slice = _ref2[_i];
        i++;
        p = "" + path + "slice_" + i + ".png";
        log(" - " + p);
        out = fs.createWriteStream(p);
        stream = slice[0].createPNGStream();
        stream.on('data', function(chunk) {
          return out.write(chunk);
        });
        _results.push(stream.on('end', function() {}));
      }
      return _results;
    };

    exports.prototype["export"] = function(url) {};

    return exports;

  })();

}).call(this);
