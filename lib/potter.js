// Generated by CoffeeScript 1.3.3
(function() {
  var Canvas, Material, async, error, fs, inspect, len, log, readPath, rgbToHex, rgbToInt, setPixel, toRGBString, wait, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  fs = require('fs');

  Canvas = require('canvas');

  _ref1 = require('./toolbox'), wait = _ref1.wait, async = _ref1.async;

  len = function(p1, p2) {
    var dx, dy, dz, sm;
    dx = p2[0] - p1[0];
    dy = p2[1] - p1[1];
    dz = p2[2] - p1[2];
    sm = dx * dx + dy * dy + dz * dz;
    return Math.round(Math.sqrt(sm));
  };

  readPath = function(p1, p2) {
    var dx, dy, dz, i, points, r, resolution, sm, x, y, z, _i;
    dx = p2[0] - p1[0];
    dy = p2[1] - p1[1];
    dz = p2[2] - p1[2];
    sm = dx * dx + dy * dy + dz * dz;
    resolution = Math.round(Math.sqrt(sm));
    if (resolution < 1) {
      return [];
    }
    points = [];
    for (i = _i = 0; 0 <= resolution ? _i <= resolution : _i >= resolution; i = 0 <= resolution ? ++_i : --_i) {
      r = i / resolution;
      x = Math.round(p1[0] + dx * r);
      y = Math.round(p1[1] + dy * r);
      z = Math.round(p1[2] + dz * r);
      points.push([x, y, z]);
    }
    return points;
  };

  toRGBString = function(num) {
    return [num >> 16, num >> 8 & 255, num & 255];
  };

  rgbToInt = function(r, g, b) {
    return (r << 16) + (g << 8) + b;
  };

  rgbToHex = function(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  };

  setPixel = function(img, x, y, r, g, b, a) {
    var index;
    index = (x + y * img.width) * 4;
    img.data[index + 0] = r;
    img.data[index + 1] = g;
    img.data[index + 2] = b;
    return img.data[index + 3] = a;
  };

  Material = (function() {

    function Material(id, name, color, type) {
      var b, g, r, _ref2;
      this.id = id;
      this.name = name;
      this.color = color;
      this.type = type != null ? type : 'continuous';
      _ref2 = this.rgb = toRGBString(this.id), r = _ref2[0], g = _ref2[1], b = _ref2[2];
      this.rgbaString = "rgba(" + r + "," + g + "," + b + ",0)";
      this.hexString = rgbToHex(r, g, b);
      this.rgbInt = rgbToInt(r, g, b);
      log("" + this);
    }

    Material.prototype.toString = function() {
      return "mat " + this.id + " (" + this.name + ") is " + this.color + " and " + this.type;
    };

    return Material;

  })();

  module.exports = (function() {

    function exports(options) {
      this.savePng = __bind(this.savePng, this);

      this.save = __bind(this.save, this);

      this.trace = __bind(this.trace, this);

      this.readVoxel = __bind(this.readVoxel, this);

      this.sphere = __bind(this.sphere, this);

      var canvas, ctx, x, _i, _ref2;
      this.size = {
        x: 32,
        y: 32,
        z: 32
      };
      if (options.size != null) {
        if (options.size.length === 3) {
          this.size.x = Math.round(Number(options.size[0]));
          this.size.y = Math.round(Number(options.size[1]));
          this.size.z = Math.round(Number(options.size[2]));
        }
      }
      this.width = Math.abs(this.size.x);
      this.height = Math.abs(this.size.y);
      this.depth = Math.abs(this.size.z);
      log("initializing " + this.depth + " slices");
      this.slices = [];
      for (x = _i = 0, _ref2 = this.depth; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; x = 0 <= _ref2 ? ++_i : --_i) {
        canvas = new Canvas(this.width, this.height);
        ctx = canvas.getContext('2d');
        this.slices.push([canvas, ctx]);
      }
      this.nbPoints = 0;
      this.materials = {};
      this.currentMaterial = false;
      this.createMaterial("vacuum", "invisible", "vacuum");
    }

    exports.prototype.createMaterial = function(name, color, type) {
      var id, material;
      id = Object.keys(this.materials).length;
      material = new Material(id, name, color, type);
      this.materials[id] = material;
      return material;
    };

    exports.prototype.use = function(material) {
      var msg;
      if (material) {
        return this.currentMaterial = material;
      } else {
        msg = "Error, no material";
        error(msg);
        throw msg;
      }
    };

    exports.prototype.dot = function(p) {
      var canvas, ctx, imgd, old, _ref2;
      _ref2 = this.slices[Math.round(p[2])], canvas = _ref2[0], ctx = _ref2[1], imgd = _ref2[2];
      old = this.readVoxel(p);
      if (old.id !== this.currentMaterial) {
        if (this.currentMaterial !== 0) {
          if (old.id === 0) {
            this.nbPoints++;
          }
        } else {
          if (this.old.id !== 0) {
            this.nbPoints--;
          }
        }
        ctx.fillStyle = this.currentMaterial.hexString;
        ctx.fillRect(Math.round(p[0]), Math.round(p[1]), 1, 1);
        return ctx.stroke();
      }
    };

    exports.prototype.line = function(p1, p2, material) {
      var p, points, _i, _len, _results;
      if (material == null) {
        material = false;
      }
      points = readPath(p1, p2);
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        _results.push(this.dot(p));
      }
      return _results;
    };

    exports.prototype.sphere = function(p, radius) {
      var M, N, f, m, n, res, s, x, y, z, _i, _results;
      res = radius;
      M = res * 3;
      N = res * 6;
      f = function(m, n) {
        return [Math.sin(Math.PI * m / M) * Math.cos(Math.PI * 2 * n / N), Math.sin(Math.PI * m / M) * Math.sin(Math.PI * 2 * n / N), Math.cos(Math.PI * m / M)];
      };
      _results = [];
      for (m = _i = 0; 0 <= M ? _i <= M : _i >= M; m = 0 <= M ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (n = _j = 0; 0 <= N ? _j < N : _j > N; n = 0 <= N ? ++_j : --_j) {
            s = f(m, n);
            _ref2 = [Math.round(p[0] + s[0] * radius), Math.round(p[1] + s[1] * radius), Math.round(p[2] + s[2] * radius)], x = _ref2[0], y = _ref2[1], z = _ref2[2];
            _results1.push(this.dot([x, y, z]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    exports.prototype.readVoxel = function(p) {
      var a, b, g, i, imgd, r, x, y, z, _ref2;
      x = p[0], y = p[1], z = p[2];
      imgd = this.slices[z][1].getImageData(0, 0, this.width, this.height);
      i = (x + y * this.width) * 4;
      _ref2 = [imgd.data[i], imgd.data[i + 1], imgd.data[i + 2], imgd.data[i + 3]], r = _ref2[0], g = _ref2[1], b = _ref2[2], a = _ref2[3];
      return this.materials[rgbToInt(r, g, b)];
    };

    exports.prototype.trace = function(keypoints, fn) {
      var i, point, points, _i, _ref2, _results;
      _results = [];
      for (i = _i = 0, _ref2 = keypoints.length - 1; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        points = readPath(keypoints[i], keypoints[i + 1]);
        _results.push((function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = points.length; _j < _len; _j++) {
            point = points[_j];
            _results1.push(fn(point));
          }
          return _results1;
        })());
      }
      return _results;
    };

    exports.prototype.save = function(path, onComplete) {
      var _this = this;
      if (onComplete == null) {
        onComplete = function() {};
      }
      return async(function() {
        var Exporter, a, b, canvas, ctx, exp, ext, g, i, imgd, material, materialId, msg, r, slice, x, y, z, _i, _j, _k, _len, _ref2, _ref3, _ref4, _ref5;
        ext = path.split(".").slice(-1);
        Exporter = require("./exporters/" + ext);
        if (!Exporter) {
          msg = "could not find exporter for format " + ext;
          error(msg);
          throw msg;
          onComplete();
          return;
        }
        exp = new Exporter(path, {
          nbPoints: _this.nbPoints,
          width: _this.width,
          height: _this.height,
          depth: _this.depth,
          matrix: function(p) {
            return _this.readVoxel(p);
          },
          onEnd: function() {
            return onComplete();
          }
        });
        z = -1;
        _ref2 = _this.slices;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          slice = _ref2[_i];
          z++;
          canvas = slice[0], ctx = slice[1];
          imgd = ctx.getImageData(0, 0, _this.width, _this.height);
          for (x = _j = 0, _ref3 = _this.width; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; x = 0 <= _ref3 ? ++_j : --_j) {
            for (y = _k = 0, _ref4 = _this.height; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; y = 0 <= _ref4 ? ++_k : --_k) {
              i = (x + y * _this.width) * 4;
              _ref5 = [imgd.data[i], imgd.data[i + 1], imgd.data[i + 2], imgd.data[i + 3]], r = _ref5[0], g = _ref5[1], b = _ref5[2], a = _ref5[3];
              materialId = rgbToInt(r, g, b);
              material = _this.materials[materialId];
              exp.write(x, y, z, material);
            }
          }
        }
        log("calling exp.close()");
        return exp.close();
      });
    };

    exports.prototype.savePng = function(path) {
      var i, out, p, slice, stream, _i, _len, _ref2, _results;
      if (path == null) {
        path = false;
      }
      log("saving:");
      i = -1;
      if (!path) {
        path = __dirname + "/";
      }
      _ref2 = this.slices;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        slice = _ref2[_i];
        i++;
        p = "" + path + "slice_" + i + ".png";
        log(" - " + p);
        out = fs.createWriteStream(p);
        stream = slice[0].createPNGStream();
        stream.on('data', function(chunk) {
          return out.write(chunk);
        });
        _results.push(stream.on('end', function() {}));
      }
      return _results;
    };

    exports.prototype["export"] = function(url) {};

    return exports;

  })();

}).call(this);
