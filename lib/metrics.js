// Generated by CoffeeScript 1.4.0
(function() {
  var Potter, compare, computeRotation, diff, difference, error, inspect, log, rotateModel, _ref;

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  Potter = require('./potter');

  diff = function(a, b) {
    var i, _diff, _i, _ref1, _results;
    _diff = function(a, b) {
      var r;
      r = a < b ? (b >= 1 ? a / b : a) : (a >= 1 ? b / a : b);
      if (r < 0.0) {
        r = 0.0;
      }
      return r;
    };
    if ((a.length != null) && (b.length != null)) {
      _results = [];
      for (i = _i = 0, _ref1 = a.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push(_diff(a[i], b[i]));
      }
      return _results;
    } else {
      return _diff(a, b);
    }
  };

  difference = exports.difference = function(pot1, pot2) {
    var adds, dels;
    adds = 0;
    dels = 0;
    pot1.each(function(p, m) {
      if (!pot2.get(p)) {
        return adds += 1;
      }
    });
    pot2.each(function(p, m) {
      if (!pot1.get(p)) {
        return dels += 1;
      }
    });
    return {
      adds: adds,
      dels: dels,
      total: adds + dels
    };
  };

  rotateModel = exports.rotateModel = function(pot1, rotation) {
    var pot2, rotatePoint;
    log("doing rotation: " + rotation);
    pot2 = new Potter({
      size: pot1.size
    });
    rotatePoint = function(x, y, amount) {
      var cosPhi, phi, sinPhi;
      if (amount === 0) {
        return [x, y];
      }
      phi = amount * Math.PI;
      cosPhi = Math.cos(phi);
      sinPhi = Math.sin(phi);
      return [x * cosPhi - y * sinPhi, x * sinPhi + y * cosPhi];
    };
    pot1.map(function(p, m) {
      var m2, xy, xz, yz;
      yz = rotatePoint(p[1], p[2], rotation[0]);
      p = [p[0], yz[0], yz[1]];
      xz = rotatePoint(p[0], p[2], rotation[1]);
      p = [xz[0], p[1], xz[1]];
      xy = rotatePoint(p[0], p[1], rotation[2]);
      p = [xy[0], xy[1], p[2]];
      p = [Math.round(p[0]), Math.round(p[1]), Math.round(p[2])];
      m2 = pot2.material(m.params);
      pot2.use(m2);
      return pot2.dot(p);
    });
    return pot2;
  };

  exports.computeRotation = computeRotation = function(pot1, pot2) {
    /*
      basically, this is a 3D binary search
      we try 4 * 4 * 4 differents rotations
      then, we get the best combination
      starting from here, we refinate the model a bit more by
      creating a range, then subdividing it again and again
      
      we start the search with these angles:
      x: [0°, 90°, 180°, 270°]
      y: [0°, 90°, 180°, 270°]
      z: [0°, 90°, 180°, 270°]
    
      eg if the best angle so far is:
      x: 270°
      y: 180°
      z: 0°
      then we can search from:
      x: [0°,   180°] / 4  -> [0°,   45°,  90°, 135°, 180°]
      y: [270°,  90°] / 4  -> [270°, 0°,   45°, 90°]
      z: [90°,  270°] / 4  -> [90°,  135°, 180°, 270°]
    
      # then again, if we run the search we might find:
      x: 45°
      y: 135°
      z: 45°
    */

  };

  compare = exports.compare = function(pot1, pot2) {
    var center1, center2, df, features, model2, nbAlive;
    features = {
      count: 0,
      transform: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0]
      }
    };
    features.count = diff(pot1.count, pot2.count);
    log("POT1:");
    center1 = pot1.outputs.barycenter.value();
    log("POT2:");
    center2 = pot2.outputs.barycenter.value();
    features.transform.translate = diff(center1, center2);
    nbAlive = function(pot) {
      return pot.sum(function(p, state) {
        return state.values[0];
      });
    };
    features.alive = diff(nbAlive(pot1), nbAlive(pot2));
    log("pot1 count: " + pot1.count + ", center: " + center1);
    log("pot2 count: " + pot2.count + ", center: " + center2);
    log("diff count: " + features.count + ",  alive: " + features.alive + ",  translate: " + features.transform.translate);
    df = difference(pot1, pot2);
    log("differential: " + (inspect(df)));
    model2 = rotateModel(pot1, [0.5, 0, 0]);
    df = difference(pot1, pot2);
    return log("differential: " + (inspect(df)));
  };

}).call(this);
